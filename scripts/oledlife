#!/usr/bin/env python3


import sys, os, re, pprint
import datetime, time
import logging, getopt
import signal

from bdb import BdbQuit

import dotlife
from dotlife import *
from dotlife.util import *
from dotlife.about import VERSION, NAME


from dotlife.life import Life
from dotlife.buffer import Buffer
from dotlife.pattern import *
from dotlife.clock import Clock, FRAME, NOW

from oledlife.mode import *
from oledlife import FRAMESIZE
from oledlife.framebuffer import FrameBuffer
from oledlife.dmx import *



DEFAULT_MODE = MODE.glider


## MAIN ########################################################################





def main(modename, device, preview, step, blend, invert, gain, **params):


    step = step * 1000.

    info( "\n" * 2 + str(PATTERN.DOTLIFE.value)[1:-1] + "\n" * 2) 
    info("oledlife mode {:s}".format(modename))



    # register signals
    signal.signal(signal.SIGQUIT, quit)
    
    # open serial
    dmx = None
    if device:
        try:
            info("open dmx {}".format(device))
            dmx = DMX(device)
        except DMXError as x:
            FATAL("open dmx {}: {}".format(device,x))

    
    Clock.Init()
    try:
        mode = MODE(modename)
    except ValueError as x:
        pass
#        usage()
    
    try:
        mode = Mode.Init(modename,step)
    except Error as x:
        FATAL("fail init mode {:s}: {:s}".format(modename,str(x)))
        
    prev = ( FRAME(), NOW() )
    pointbreak= False
    while True:
        try:
            Clock.Tick()
            framebuffer = FrameBuffer()

            buffer = mode.draw()

            if blend == dotlife.Blend.Jump:
                pass
            elif blend == dotlife.Blend.Black:
                buffer.mul( mode.timer.sin0(1.) )
            elif blend == dotlife.Blend.Frame:
                buffer.mul(16. * (mode.timer.ease(freq=4.)))
                tmp = Buffer()
                tmp.add( mode.last )
                tmp.mul(16. * (1. - mode.timer.ease(freq=4.)))
                buffer.add( tmp )
        
            
            if gain != 0x00:
                buffer.mul( gain )
        
            framebuffer.add( buffer )

            if dmx:
                send(dmx,framebuffer)

            if FRAME() % 60 == 0:
                if FRAME() % 600 == 0:
                    debug("{:s} {:.1f}fps {:s}".format(Clock.Str(),fps(prev),str(mode)))
                prev = ( FRAME(), NOW() )

            if preview:
                Y = FRAMESIZE.h+1
                columns,lines = os.get_terminal_size()
                up   = "\u001b[{:d}A".format( FRAMESIZE.w + 1 + Y )
                down   = "\u001b[1E"
                right = "\u001b[{:d}C".format(columns - ((FRAMESIZE.w+2) * 2 ))
                buf = str(framebuffer).split("\n")
                sys.stdout.write(up)
                for i in range(Y):
                    sys.stdout.write( right + 20*" " + down)
                for s in buf:
                    sys.stdout.write(right + s + down)
                sys.stdout.write( right + 20*" " + down)
                sys.stdout.flush()

#            Clock.Sleep()
            
        except Error as x:
            FATAL("error: {:s}".format( str(x) ))
    

        except KeyboardInterrupt as x:
            info("user interrupt")  
            break
    
        except SystemExit as x:
            info("exit.")
            break
   
        except BrokenPipeError:
            error("broken pipe, disable preview")
            preview = False
   
#       except Exception as x:
#            FATAL("unexpected: " + repr(x) )
            

def fps(prev):
    (frame, time) = prev
    return float( (FRAME() - frame) /  ((NOW() - time)/1000.) )


def send(dmx,framebuffer):
    try:
        frame = framebuffer.bytes()
        dmx.send(frame)
    except DMXError as x:
        error("fail send {:d} byte: {}".format(len(frame),x))
        

def quit(sig,frame):
    log("exit.")   
    sys.exit(0)




    








## PARAMS ######################################################################
    
    
    

FLAGS = [
    # short long param default help func #             
    ("S:", "serial=",           "device",              "",                      "serial device",                                              None ),
    ("v",  "verbose",           None,                  None,                    "increase verbosity",                                         None ),
    ("P", "preview",            "preview",             False,                   "preview on stdout",                                          None ),                  
    ("V",  "version",           None,                  None,                    "display version",                                            None ),
    ("h",  "help",              None,                  None,                    "display help",                                               None ),
]

MODEFLAGS = [
    # short long param default help func #             
    ("", "",                   "modename",             DEFAULT_MODE.name,      "mode",          None ),
    ("b:", "blend=",            "blend",               dotlife.Blend.Jump.name,"blend style {}".format(",".join([ b.name for b in Blend])), lambda x : dotlife.Blend(x) ),
    ("s:", "step=",             "step",                1.0,                     "step speed",                                                 lambda x : float(x) ),
    ("",   "inv",               "invert",              False,                   "invert brightness",                                          None ),
    ("",   "gain=",             "gain",                1.0,                     "gain brightness",                                            lambda x: float(x) ),
]

PARAMS = FLAGS + MODEFLAGS






def usage():
    if len(logging.getLogger(NAME).handlers) > 0:
        logging.getLogger(NAME).handlers[0].setFormatter( logging.Formatter( "%(message)s") )
        
    log("""## Usage

{} [-{}] {} <MODE>
""".format(
        "oledlife",
        "".join([s[0] if len(s) >= 1 else "" for (s,_,_,_,_,_) in FLAGS]),
        " ".join(["[--{:s}]".format(l) if len(l) >= 1 else "" for (_,l,_,_,_,_) in MODEFLAGS]),
        )
    )

    log("## Flags")
    for (s,l,p,d,h,_) in FLAGS:
        if not s and not l:
            continue
        log("  {:3} {:20}    {}{}".format( "-"+s.rstrip(":")+"," if s else "","--"+l.rstrip("=") if l else "",h,("" if d is None else ", default "+str(d).lower()) ))
    log("")

    for (s,l,p,d,h,_) in MODEFLAGS:
        if not s and not l:
            continue
        log("  {:3} {:20}    {}{}".format( "-"+s.rstrip(":")+"," if s else "","--"+l.rstrip("=") if l else "",h,("" if d is None else ", default "+str(d).lower()) ))
    log("")

    log("## Modes")
    modes = ""
    for k in MODE:
        modes += " " + k.name
        if len(modes) > 40:
            log("{:s}".format(modes))
            modes = ""
    log("{:s}".format(modes))
    log("")
#    for k in MODE:
#        log("  {:8} {:15}    {}".format(k.name,"",""))
#    log("")

    exit(-1)

    
## UTILITY #####################################################################

#REM, raspbian utf8 trouble: https://unix.stackexchange.com/questions/347914/how-to-set-lc-all-en-gb-utf-8-in-raspbian

def about():
    if len(logging.getLogger(NAME).handlers) > 0:
        logging.getLogger(NAME).handlers[0].setFormatter( logging.Formatter( "%(message)s") )
    log("""\
{} {}
Â©2020 FEEDFACE.COM
""".format(NAME,VERSION) )
    exit(0)
    
    
    


if __name__ == "__main__":

    verbosity = logging.WARNING
    logger = logging.getLogger(NAME)
    handler = logging.StreamHandler()
    formatter = logging.Formatter("%(message)s")
    handler.setFormatter(formatter)
    handler.setLevel(verbosity)
    logger.setLevel(verbosity)
    logger.addHandler(handler)
    
    
    short = "".join( [s for (s,_,_,_,_,_) in PARAMS if s is not None] )
    long = [l for (_,l,_,_,_,_) in PARAMS if l is not None] 
    params = dict( [(n,d) for (_,_,n,d,_,_) in PARAMS if n is not None] )
    
    try:
        opts, args = getopt.getopt(sys.argv[1:],short,long)
    except getopt.GetoptError as x:
        error("{}".format(x))
        usage()
    
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            usage()
        elif opt in ("-V", "--version"):
            about()
        elif opt in ("-v", "--verbose"):
            if verbosity == logging.WARNING:
                verbosity = logging.INFO
            elif verbosity == logging.INFO:
                verbosity = logging.DEBUG
            logger.setLevel(verbosity)
            handler.setLevel(verbosity)
        elif opt in ("-q", "--quiet"):
            verbosity = logging.ERROR
            logger.setLevel(verbosity)
            handler.setLevel(verbosity)
        elif opt in ("-P", "--preview"):
            params["preview"] = True
        else:
            for (s,l,p,_,h,f) in PARAMS:
                if s is None and l is None:
                    continue
                if opt in ["-"+s.rstrip(":"),"--"+l.rstrip("=")]:
                    fun = f if f else lambda x: x
                    if s.endswith(":") or l.endswith("="):
                        try:
                            params[p] = fun(arg)
                        except Exception as x:
                            error("invalid argument: {} {}".format(opt,arg))
                            usage()
                    else:
                        params[p] = True
                    break
            else:
                error("internal error: option {} not implemented.".format(opt))
                usage()            

    for (s,l,n,_,_,_) in PARAMS:
        if n and params[n] is None:
            error("mandatory parameter {}/{} missing.".format("-"+s.rstrip(":") if s else "","--"+l.rstrip("=") if l else ""))
            usage()

    if len(args) >= 1:
        params['modename'] = args[0]
    
    if len(args) > 1:
        if args[1] == "-h":
            usage()


#    dump(params)
    exit( main(**params) )
    
   
