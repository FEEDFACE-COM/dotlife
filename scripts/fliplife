#!/usr/bin/env python3


import sys, os, re, pprint
import datetime, time
import logging, getopt
import signal, socket
import math

from bdb import BdbQuit

import dotlife
from dotlife import *
from dotlife.util import *
from dotlife.about import NAME, VERSION


from dotlife.pattern import PATTERN
from dotlife.font import Font, FONT
from dotlife.clock import Clock, FRAME, NOW

import fliplife
from fliplife import MODE, DEFAULT_FONT
from fliplife.mode import Class
from fliplife import Mask, FRAMESIZE
from fliplife.fluepdot import Fluepdot

DEFAULT_MODE = MODE.read
DEFAULT_HOST = "87.193.3.53"

## MAIN ########################################################################





def main(runmode, host, speed, clear, forever, nowrite, noread, preview, **params):

    info("fliplife start".format())

    # register signals
    signal.signal(signal.SIGQUIT, quit)
    
    
    address = ""
    try:
        address = socket.gethostbyname(host)
    except socket.gaierror as x:
        FATAL("fail to get address for {:s}: {:s}".format(host,str(x)))
    
    
    
    Clock.Init()

    fluepdot = Fluepdot(address,nowrite,noread)
    timer = Clock.Timer(speed,repeat=True)
    mask = Mask()
    
    if not clear:
        info("get display buffer")
        mask = fluepdot.buffer.read()
            
    try:
        mode = runmode.value(fluepdot,timer,mask)
    except Error as x:
        FATAL("fail init mode {:s}: {:s}".format(runmode.name,str(x)))



    try:
        run = mode.run(**params)
        drawbuffer = []
        while run and forever:
            Clock.Tick()
            info("{:s} {:s}".format(Clock.Str(),str(mode)))
            
            if len(drawbuffer) > 0:
                buf = drawbuffer[0]
                drawbuffer = drawbuffer[1:]
                debug("write drawbuffer, {:d} remaining".format(len(drawbuffer)))
                fluepdot.buffer.write(buf)
                if preview:
                    printBuffer(str(buf))
                Clock.Sleep( speed )
            
            else:
                draw = mode.draw(**params)
                if type(draw) == type([]):
                    drawbuffer = draw
#                    info("new drawbuffer: {:d} elements".format(len(drawbuffer)))
                    continue
                    
                elif type(draw) == type(Mask()):
                    buf = draw
                    fluepdot.buffer.write(buf)
                    info(str(buf))
                    Clock.Sleep( speed )
                    



    except KeyboardInterrupt as x:
        info("user interrupt.") 
        
    except Error as x:
        FATAL("error: {:s}".format( str(x) ))
    
    except SystemExit as x:
        info("exit.")
   
#    except Exception as x:
#        FATAL("unexpected: " + repr(x) )
            

        

def quit(sig,frame):
    log("exit.")   
    sys.exit(0)


def printBuffer(buf):
    height = int(math.ceil(FRAMESIZE.h/2))
    width  = int(math.ceil(FRAMESIZE.w/2))
    Y = 2
    columns,lines = os.get_terminal_size()
    up   = "\u001b[{:d}A".format( height  + 1 + Y )
    down   = "\u001b[1E"
    right = "\u001b[{:d}C".format( columns - (width+3)  )
#    up,down,right = "","\n",""
    sys.stdout.write(up)
    for i in range(Y):
        sys.stdout.write( right + (1+width)*" " + down)
    for s in buf.split("\n"):
        sys.stdout.write(right + s + down)
    sys.stdout.write( right + (1+width)*" " + down)
    sys.stdout.flush()






## FLAGS #######################################################################
    

HELPFLAGS = [
        ("h",  "help",         None,                None,    "display help",           None ),
]

FLAGS = [
    # short long param default help func #             
    ("h",  "help",         None,                None,    "display help",           None ),
    ("H:", "host=",        "host",      DEFAULT_HOST,    "fluepdot host",          None ),
    ("W",  "nowrite",      "nowrite",          False,    "no writes to fluepdot?", None ),
    ("R",  "noread",       "noread",           False,    "no reads from fluepdot?",None ),
    ("C",  "clear",        "clear",             True,    "clear fluepdot?",        None ),
    ("F",  "forever",      "forever",          False,    "run continuously?",      None ),
    ("P",  "preview",      "preview",          False,    "buffer preview on stdout?",      None ),
    ("v",  "",      None,                None,    "increase verbosity",     None ),
    ("V",  "",      None,                None,    "display version",        None ),
]




## UTILITY #####################################################################



def usage(mode=None,msg=""):

    from dotlife.util import usage as log
    
    
    if msg != "":
        log("##")
        log("## Usage Error: " + msg)
        log("##")
        log("")
    
    if mode == None:
    
        log("## Usage")
        log("  {} [-{}] {} <mode>  ...".format(
            "fliplife",
            "".join([s[0] if s else "" for (s,_,_,_,_,_) in FLAGS]),
            "".join(["[--{:s}] ".format(l) if not s and l else "" for (s,l,_,_,_,_) in FLAGS]),
            )
        )
        log("")
        
        log("## Flags")
        for (s,l,p,d,h,_) in FLAGS:
            if not p:
                continue
            log("  {:3} {:20}    {}{}".format( "-"+s.rstrip(":")+"," if s else "","--"+l.rstrip("=") if l else "",h,("" if d in [None,False] else ", default: "+str(d).lower()) ))
        log("")

        log("## Modes")
        modes = "  "
        for k in MODE:
#            log("  {:16s}{:s}".format(k.name,k.value.help))
            modes += k.name + " "
            if len(modes) > 40:
                log(modes)
                modes = "  "
        log(modes)
        log("")
    
    else:
        log("## Usage")
        log("")
        
        log("  {} {} [-{}] {}".format(
                "fliplife",
                mode.name,
                "".join([s[0] if s else "" for (s,_,_,_,_,_) in mode.value.flags]),
                "".join(    p if not s and not l else "" for (s,l,p,_,_,_) in mode.value.flags),
            )
        )
        log("")
        
        log("## Flags")
        f = None
        for (s,l,p,d,h,_) in fliplife.mode.Mode.FLAGS + mode.value.flags:
            if s or l:
                log("  {:3} {:16}    {}{}".format( "-"+s.rstrip(":")+"," if s else "","--"+l.rstrip("=") if l else "",h,("" if d in [None,False] else ", default: "+str(d).lower()) ))
        log("")
    

            
        fonts,patterns = [],[]
        for (_,_,p,_,_,_) in mode.value.flags:
            if p == "font":
                for f in dotlife.font.FONT:
                    fonts += [f]
            if p == "pattern":
                for p in mode.value.patterns:
                    patterns += [p]

        if fonts:
            log("## Fonts")
            fnt = ""
            for f in fonts:
                fnt += str(f) + " "
                if len(fnt) > 40:
                    log("  " + fnt)
                    fnt = ""
            log("  " + fnt)
            log("")

        if patterns:
            log("## Patterns")
            pat = ""
            for p in patterns:
                pat += str(p) + " "
                if len(pat) > 40:
                    log("  " + pat)
                    pat = ""
            log("  " + pat)
            log("")
        

        args = None
        for (s,l,p,d,h,_) in mode.value.flags:
            if not s and not l:
                args = "  {:20}    {}{}".format( p,h,("" if d in [None,False] else ", default: "+str(d).lower()) )
        if args:
            log("## Arguments")
            log(args)
            log("")
        
    exit(-1)

    


def about():
    sys.stderr.write("""\
fliplife {}
Â©2020 FEEDFACE.COM
""".format(VERSION) )
    exit(0)
    
    
    
## MAIN ########################################################################


if __name__ == "__main__":

    verbosity = logging.WARNING
    logger = logging.getLogger(NAME)
    handler = logging.StreamHandler()
    formatter = logging.Formatter("%(message)s")
    handler.setFormatter(formatter)
    handler.setLevel(verbosity)
    logger.setLevel(verbosity)
    logger.addHandler(handler)
    
    
    
    ## read global flags
    short = "".join( [s for (s,_,_,_,_,_) in FLAGS+HELPFLAGS if s is not None] )
    long = [l for (_,l,_,_,_,_) in FLAGS+HELPFLAGS if l is not None] 
    params = dict( [(n,d) for (_,_,n,d,_,_) in FLAGS if n is not None] )
    
    try:
        opts, args = getopt.getopt(sys.argv[1:],short,long)
    except getopt.GetoptError as x:
        usage(None,"{}".format(x))
    
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            usage()
        elif opt in ("-V", "--version"):
            about()
        elif opt in ("-v", "--verbose"):
            verbosity -= 10
            logger.setLevel(verbosity)
            handler.setLevel(verbosity)
        elif opt in ("-q", "--quiet"):
            verbosity = logging.ERROR
            logger.setLevel(verbosity)
            handler.setLevel(verbosity)
        else:
            for (s,l,p,_,h,f) in FLAGS:
                if s is None and l is None:
                    continue
                if opt in ["-"+s.rstrip(":"),"--"+l.rstrip("=")]:
                    fun = f if f else lambda x: x
                    if s.endswith(":") or l.endswith("="):
                        try:
                            params[p] = fun(arg)
                        except Exception as x:
                            usage(None,"invalid argument: {} {}".format(opt,arg))
                    else:
                        params[p] ^= True
                    break
            else:
                usage(None,"internal error: option {} not implemented.".format(opt))

    for (s,l,n,_,_,_) in FLAGS:
        if n and params[n] is None:
            usage(None,"mandatory parameter {}/{} missing.".format("-"+s.rstrip(":") if s else "","--"+l.rstrip("=") if l else ""))

    ## read mode
    runmode = DEFAULT_MODE
    if len(args) >= 1:
        try:
            runmode = MODE[ args[0] ]
            args = args[1:]
        except KeyError:
            usage(None,"invalid mode: {:s}".format(args[0]))



    ## read mode flags
    modeflags = HELPFLAGS + fliplife.mode.Mode.FLAGS + runmode.value.flags
    short = "".join( [s for (s,_,_,_,_,_) in modeflags if s is not None] )
    long = [l for (_,l,_,_,_,_) in modeflags if l is not None] 
    modeparams = dict( [(n,d) for (_,_,n,d,_,_) in modeflags if n is not None] )
    

    try:
        opts, args = getopt.getopt(args,short,long)
    except getopt.GetoptError as x:
        usage(runmode,str(x))
    

    for opt, arg in opts:
        if opt in ("-h", "--help"):
            usage(runmode)
        else:
            for (s,l,p,_,h,f) in modeflags:
                if opt in ["-"+s.rstrip(":"),"--"+l.rstrip("=")]:
                    fun = f if f else lambda x: x
                    if s.endswith(":") or l.endswith("="):
                        try:
                            modeparams[p] = fun(arg)
                        except Exception as x:
                            usage(runmode,"invalid argument: {} {}".format(opt,arg))
                    else:
                        modeparams[p] = True
                    break
            else:
                usage(runmode,"internal error: option {} not implemented.".format(opt))            


    ## read remainder into no-flags mode param    
    for (s,l,p,_,_,_) in modeflags:
        if not s and not l:
            modeparams[p] = " ".join(args)
        

#    dump(params)
    exit( main(runmode,**params,**modeparams) )
    
   
