#!/usr/bin/env python3


import sys, os, re, pprint
import datetime, time
import logging, getopt
import signal, socket
import math

from bdb import BdbQuit

import dotlife
from dotlife import *
from dotlife.util import *
from dotlife.about import NAME, VERSION


from dotlife.pattern import PATTERN
from dotlife.font import Font, FONT
from dotlife.clock import Clock, FRAME, NOW

import fliplife
from fliplife.mode import *
from fliplife import Mask, FRAMESIZE
from fliplife.fluepdot import Fluepdot

DEFAULT_MODE = MODE.read
DEFAULT_FONT = FONT.font3x5
DEFAULT_HOST = "87.193.3.53"

## MAIN ########################################################################





def main(runmode, host, preview, speed, clear, forever, nowrite, noread, **params):

    info( "\n\n" + str(PATTERN.FLIPLIFE.value)[1:-1] + "\n\n")
    info("fliplife mode {:s}".format(runmode.name))

    # register signals
    signal.signal(signal.SIGQUIT, quit)
    
    
    address = ""
    try:
        address = socket.gethostbyname(host)
    except socket.gaierror as x:
        FATAL("fail to get address for {:s}: {:s}".format(host,str(x)))
    
    
    
    Clock.Init()

    fluepdot = Fluepdot(address,nowrite,noread)
    timer = Clock.Timer(speed,repeat=True)
    
    try:
        m = Class(runmode)
        mode = m(fluepdot,timer)
    except Error as x:
        FATAL("fail init mode {:s}: {:s}".format(runmode.name,str(x)))


    if clear:
        info("clear display")
        fluepdot.buffer.write(Mask())

    try:
        run = mode.run(**params)
        while run and forever:
            Clock.Tick()
            Clock.Sleep( speed )
            buf = mode.draw(**params)
            debug("{:s} {:s}".format(Clock.Str(),str(mode)))
            printBuffer(str(buf))
            
    except KeyboardInterrupt as x:
        info("user interrupt.") 
        
    except Error as x:
        FATAL("error: {:s}".format( str(x) ))
    
    except SystemExit as x:
        info("exit.")
   
    except BrokenPipeError:
        error("broken pipe, disable preview")

#       except Exception as x:
#            FATAL("unexpected: " + repr(x) )
            

        

def quit(sig,frame):
    log("exit.")   
    sys.exit(0)







def printBuffer(buf):
    return
    height = int(math.ceil(FRAMESIZE.h/2))
    width  = int(math.ceil(FRAMESIZE.w/2))
    Y = 1
    columns,lines = os.get_terminal_size()
    up   = "\u001b[{:d}A".format( height  + 1 + Y )
    down   = "\u001b[1E"
    right = "\u001b[{:d}C".format( columns - (width+3)  )
#    up,down,right = "","\n",""
    sys.stdout.write(up)
    for i in range(Y):
        sys.stdout.write( right + (1+width)*" " + down)
    for s in buf.split("\n"):
        sys.stdout.write(right + s + down)
    sys.stdout.write( right + (1+width)*" " + down)
    sys.stdout.flush()





## FLAGS #######################################################################
    
    
    

FLAGS = [
    # short long param default help func #             
    ("v",  "verbose",      None,                None,    "increase verbosity",     None ),
    ("P", "preview",       "preview",          False,    "preview on stdout",      None ),                  
    ("V",  "version",      None,                None,    "display version",        None ),
    ("h",  "help",         None,                None,    "display help",           None ),
    ("H:", "host=",        "host",      DEFAULT_HOST,    "fluepdot host",          None ),
    ("W",  "nowrite",      "nowrite",          False,    "no writes to fluepdot?", None ),
    ("R",  "noread",       "noread",           False,    "no reads from fluepdot?",None ),
]

MODEFLAGS = [
    # short long param default help func #             
    ("",   "",                 "runmode",              DEFAULT_MODE,           "mode",                                 lambda x: MODE.named(x) ),
    ("",   "",                 "rem",                  "",                     "remainder"        ,                                       None ),
    ("C",  "clear",            "clear",                False,                  "clear display?",                                          None ),
    ("F",  "forever",          "forever",              False,                  "run continuously?",                                       None ),
    ("i",  "invert",           "invert",               False,                  "invert pattern?",                                         None ),
    ("s:", "speed=",           "speed",                1.0,                    "step speed [s]",                           lambda x : float(x) ),
    ("c:", "count=",           "count",                1,                      "count",                                      lambda x : int(x) ),
    ("f:", "font=",            "font",                 DEFAULT_FONT,           "font",                                 lambda x: FONT.named(x) ),
    ("p:", "pattern=",         "pattern",              "default",              "pattern",                                                 None ),
    ("q:", "step=",            "step",                 0,                      "pattern step",                               lambda x : int(x) ),
    ("x:", "",                 "x",                    0,                      "x offset",                                   lambda x : int(x) ),
    ("y:", "",                 "y",                    0,                      "y offset",                                   lambda x : int(x) ),
    ("r", "random",            "randomize",            False,                  "randomize?",                                              None ),
]

ALLFLAGS = FLAGS + MODEFLAGS






def usage(mode=None):
#    if len(logging.getLogger(NAME).handlers) > 0:
#        logging.getLogger(NAME).handlers[0].setFormatter( logging.Formatter( "%(message)s") )
    
    log("""## Usage

{} [-{}] {} <mode> <msg/cmd/...>
""".format(
        "fliplife",
        "".join([s[0] if s else "" for (s,_,_,_,_,_) in FLAGS]),
        "".join(["[--{:s}] ".format(l) if not s and l else "" for (s,l,_,_,_,_) in MODEFLAGS]),
        )
    )

    log("## Flags")
    for (s,l,p,d,h,_) in FLAGS:
        if not s and not l:
            continue
        log("  {:3} {:20}    {}{}".format( "-"+s.rstrip(":")+"," if s else "","--"+l.rstrip("=") if l else "",h,("" if d in [None,False] else ", default "+str(d).lower()) ))
    log("")

    for (s,l,p,d,h,_) in MODEFLAGS:
        if not s and not l:
            continue
        log("  {:3} {:20}    {}{}".format( "-"+s.rstrip(":")+"," if s else "","--"+l.rstrip("=") if l else "",h,("" if d in [None,False] else ", default "+str(d).lower()) ))
    log("")

    log("## Modes")
    modes = ""
    for k in MODE:
        modes += " " + k.name
        if len(modes) > 40:
            log("{:s}".format(modes))
            modes = ""
    log("{:s}".format(modes))
    log("")

    log("## Fonts")
    log("  DejaVuSans12bw_bwfont fixed_10x20 fixed_7x14 fixed_5x8")
    log("  DejaVuSerif32 DejaVuSerif16 DejaVuSans12bw DejaVuSans12")    
    log("")

    exit(-1)

    
## UTILITY #####################################################################


def about():
    sys.stderr.write("""\
fliplife {}
Â©2020 FEEDFACE.COM
""".format(VERSION) )
    exit(0)
    
    
    


if __name__ == "__main__":

    verbosity = logging.WARNING
    logger = logging.getLogger(NAME)
    handler = logging.StreamHandler()
    formatter = logging.Formatter("%(message)s")
    handler.setFormatter(formatter)
    handler.setLevel(verbosity)
    logger.setLevel(verbosity)
    logger.addHandler(handler)
    
    
    short = "".join( [s for (s,_,_,_,_,_) in ALLFLAGS if s is not None] )
    long = [l for (_,l,_,_,_,_) in ALLFLAGS if l is not None] 
    params = dict( [(n,d) for (_,_,n,d,_,_) in ALLFLAGS if n is not None] )
    
    try:
        opts, args = getopt.getopt(sys.argv[1:],short,long)
    except getopt.GetoptError as x:
        error("{}".format(x))
        usage()
    
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            usage()
        elif opt in ("-V", "--version"):
            about()
        elif opt in ("-v", "--verbose"):
            verbosity -= 10
            logger.setLevel(verbosity)
            handler.setLevel(verbosity)
        elif opt in ("-q", "--quiet"):
            verbosity = logging.ERROR
            logger.setLevel(verbosity)
            handler.setLevel(verbosity)
        elif opt in ("-P", "--preview"):
            params["preview"] = True
        else:
            for (s,l,p,_,h,f) in ALLFLAGS:
                if s is None and l is None:
                    continue
                if opt in ["-"+s.rstrip(":"),"--"+l.rstrip("=")]:
                    fun = f if f else lambda x: x
                    if s.endswith(":") or l.endswith("="):
                        try:
                            params[p] = fun(arg)
                        except Exception as x:
                            error("invalid argument: {} {}".format(opt,arg))
                            error(str(x))
                            usage()
                    else:
                        params[p] = True
                    break
            else:
                error("internal error: option {} not implemented.".format(opt))
                usage()            

    for (s,l,n,_,_,_) in ALLFLAGS:
        if n and params[n] is None:
            error("mandatory parameter {}/{} missing.".format("-"+s.rstrip(":") if s else "","--"+l.rstrip("=") if l else ""))
            usage()

    if len(args) >= 1:
        try:
            params['runmode'] = fliplife.mode.MODE[ args[0] ]
        except KeyError:
            error("invalid mode {:s}".format(args[0]))
            usage()

    runmode = params['runmode']
    m = fliplife.mode.Class(runmode)
    
    
    
    
    

    
#    if len(args) > 1:
#        if args[1] == "-h":
#            usage()
#        params['rem'] = args[1:] 


#    dump(params)
    exit( main(**params) )
    
   
