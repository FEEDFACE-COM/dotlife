#!/usr/bin/env python3


import sys, os, re, pprint
import datetime, time
import logging, getopt
import signal, socket
import math

from bdb import BdbQuit

import dotlife
from dotlife import *
from dotlife.util import *
from dotlife.about import VERSION, NAME


from dotlife.life import Life
from dotlife.buffer import Buffer
from dotlife.pattern import *
from dotlife.clock import Clock, FRAME, NOW

from fliplife.mode import *
from fliplife import FRAMEWIDTH,FRAMEHEIGHT
from fliplife.mask import Mask



DEFAULT_MODE = MODE.test

DEFAULT_HOST = "87.193.3.53"

## MAIN ########################################################################





def main(modename, host, preview, step, **params):


    step = step * 1000.

    info( "\n" * 2 + str(PATTERN.DOTLIFE.value)[1:-1] + "\n" * 2) 
    info("fliplife mode {:s}".format(modename))



    # register signals
    signal.signal(signal.SIGQUIT, quit)
    
    
    address = ""
    try:
        address = socket.gethostbyname(host)
    except socket.gaierror as x:
        FATAL("fail to get address for {:s}: {:s}".format(host,str(x)))
    
    
    Clock.Init()
    try:
        _ = MODE(modename)
    except ValueError as x:
        usage()
    
    try:
        mode = Mode.Init(modename,address,printBuffer,step)
    except Error as x:
        FATAL("fail init mode {:s}: {:s}".format(modename,str(x)))

    try:
        run = mode.run(**params)
        while run:
            Clock.Tick()
            buf = mode.draw(**params)
            printBuffer(str(buf))
            Clock.Sleep( step )
            
    except KeyboardInterrupt as x:
        info("user interrupt") 
        
    except Error as x:
        FATAL("error: {:s}".format( str(x) ))
    
    except SystemExit as x:
        info("exit.")
   
    except BrokenPipeError:
        error("broken pipe, disable preview")

#       except Exception as x:
#            FATAL("unexpected: " + repr(x) )
            

        

def quit(sig,frame):
    log("exit.")   
    sys.exit(0)




    



def printBuffer(buf):
    height = int(math.ceil(FRAMEHEIGHT/2))
    width  = int(math.ceil(FRAMEWIDTH/2))
    Y = 1
    columns,lines = os.get_terminal_size()
    up   = "\u001b[{:d}A".format( height  + 1 + Y )
    down   = "\u001b[1E"
    right = "\u001b[{:d}C".format( columns - (width+3)  )
#    up,down,right = "","\n",""
    sys.stdout.write(up)
    for i in range(Y):
        sys.stdout.write( right + (1+width)*" " + down)
    for s in buf.split("\n"):
        sys.stdout.write(right + s + down)
    sys.stdout.write( right + (1+width)*" " + down)
    sys.stdout.flush()





## PARAMS ######################################################################
    
    
    

FLAGS = [
    # short long param default help func #             
    ("v",  "verbose",      None,                None,    "increase verbosity", None ),
    ("P", "preview",       "preview",          False,    "preview on stdout",  None ),                  
    ("V",  "version",      None,                None,    "display version",    None ),
    ("h",  "help",         None,                None,    "display help",       None ),
    ("H:", "host=",         "host",      DEFAULT_HOST,   "fluepdot host",      None ),
]

MODEFLAGS = [
    # short long param default help func #             
    ("", "",                   "modename",             DEFAULT_MODE.name,      "mode",                         lambda x: fliplife.mode.Mode(x) ),
    ("",   "",                 "msg",                  "",                     "message",                                                 None ),
    ("s:", "step=",            "step",                 1.0,                    "step speed [s]",                           lambda x : float(x) ),
    ("f:", "font=",            "font",                 "fixed_5x8",            "font",                                                    None ),
    ("x:", "",                 "xoff",                 0,                      "x offset",                                   lambda x : int(x) ),
    ("y:", "",                 "yoff",                 0,                      "y offset",                                   lambda x : int(x) ),
    ("R", "random",            "randomize",            False,                  "randomize",                                               None ),
]

PARAMS = FLAGS + MODEFLAGS






def usage():
    if len(logging.getLogger(NAME).handlers) > 0:
        logging.getLogger(NAME).handlers[0].setFormatter( logging.Formatter( "%(message)s") )
        
    log("""## Usage

{} [-{}] {} <mode> <msg..>
""".format(
        "fliplife",
        "".join([s[0] if len(s) >= 1 else "" for (s,_,_,_,_,_) in FLAGS]),
        " ".join(["[--{:s}]".format(l) if len(l) >= 1 else "" for (_,l,_,_,_,_) in MODEFLAGS]),
        )
    )

    log("## Flags")
    for (s,l,p,d,h,_) in FLAGS:
        if not s and not l:
            continue
        log("  {:3} {:20}    {}{}".format( "-"+s.rstrip(":")+"," if s else "","--"+l.rstrip("=") if l else "",h,("" if d is None else ", default "+str(d).lower()) ))
    log("")

    for (s,l,p,d,h,_) in MODEFLAGS:
        if not s and not l:
            continue
        log("  {:3} {:20}    {}{}".format( "-"+s.rstrip(":")+"," if s else "","--"+l.rstrip("=") if l else "",h,("" if d is None else ", default "+str(d).lower()) ))
    log("")

    log("## Modes")
    for k in MODE:
        log("  {:8} {:15}    {}".format(k.name,"",""))
    log("")

    log("## Fonts")
    log("  DejaVuSans12bw_bwfont fixed_10x20 fixed_7x14 fixed_5x8")
    log("  DejaVuSerif32 DejaVuSerif16 DejaVuSans12bw DejaVuSans12")    
    log("")

    exit(-1)

    
## UTILITY #####################################################################

#REM, raspbian utf8 trouble: https://unix.stackexchange.com/questions/347914/how-to-set-lc-all-en-gb-utf-8-in-raspbian

def about():
    if len(logging.getLogger(NAME).handlers) > 0:
        logging.getLogger(NAME).handlers[0].setFormatter( logging.Formatter( "%(message)s") )
    log("""\
{} {}
Â©2020 FEEDFACE.COM
""".format(NAME,VERSION) )
    exit(0)
    
    
    


if __name__ == "__main__":

    verbosity = logging.WARNING
    logger = logging.getLogger(NAME)
    handler = logging.StreamHandler()
    formatter = logging.Formatter("%(message)s")
    handler.setFormatter(formatter)
    handler.setLevel(verbosity)
    logger.setLevel(verbosity)
    logger.addHandler(handler)
    
    
    short = "".join( [s for (s,_,_,_,_,_) in PARAMS if s is not None] )
    long = [l for (_,l,_,_,_,_) in PARAMS if l is not None] 
    params = dict( [(n,d) for (_,_,n,d,_,_) in PARAMS if n is not None] )
    
    try:
        opts, args = getopt.getopt(sys.argv[1:],short,long)
    except getopt.GetoptError as x:
        error("{}".format(x))
        usage()
    
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            usage()
        elif opt in ("-V", "--version"):
            about()
        elif opt in ("-v", "--verbose"):
            if verbosity == logging.WARNING:
                verbosity = logging.INFO
            elif verbosity == logging.INFO:
                verbosity = logging.DEBUG
            logger.setLevel(verbosity)
            handler.setLevel(verbosity)
        elif opt in ("-q", "--quiet"):
            verbosity = logging.ERROR
            logger.setLevel(verbosity)
            handler.setLevel(verbosity)
        elif opt in ("-P", "--preview"):
            params["preview"] = True
        else:
            for (s,l,p,_,h,f) in PARAMS:
                if s is None and l is None:
                    continue
                if opt in ["-"+s.rstrip(":"),"--"+l.rstrip("=")]:
                    fun = f if f else lambda x: x
                    if s.endswith(":") or l.endswith("="):
                        try:
                            params[p] = fun(arg)
                        except Exception as x:
                            error("invalid argument: {} {}".format(opt,arg))
                            usage()
                    else:
                        params[p] = True
                    break
            else:
                error("internal error: option {} not implemented.".format(opt))
                usage()            

    for (s,l,n,_,_,_) in PARAMS:
        if n and params[n] is None:
            error("mandatory parameter {}/{} missing.".format("-"+s.rstrip(":") if s else "","--"+l.rstrip("=") if l else ""))
            usage()

    if len(args) >= 1:
        params['modename'] = args[0]
    
    if len(args) > 1:
        params['msg'] = args[1:] 


#    dump(params)
    exit( main(**params) )
    
   
